\chapter{Using Bloomaps in points-to analysis}

In this chapter we discuss the internals of points-to analysis as
implemented in the GCC compiler and how it was augmented by the use of Bloomaps
instead of regular bitmaps. We will then show how the change affected GCC and
discuss future work.

\section{Points-to analysis in GCC}

The points-to analysis in GCC is implemented in two files. In {\tt
tree-ssa-alias.c} contains the alias oracle and the TBAA and Base-offset
algorithms (see sections \ref{sec-tbaa} and\ref{sec-baseoffset}).
Function {\tt refs\_may\_alias\_p(tree,tree)} wraps most of the functionality,
but a few others exist to check for aliasing with global memory, call clobbers
and other special cases. It also contains interface to alias analysis on RTL
objects, which query the oracles listed above.

The points-to information is stored in a structure {\tt pt\_solution}, which is
computed by algorithm in {\tt tree-ssa-structalias.c}. It is an implementation
based on \cite{Pearce2004,Heintze2001}, and is an Andersen-style algorithm. An
overview of this algorithm is on Figure \ref{figure-gcc-aliasalg}.


\begin{figure}[h!]
\begin{tcolorbox}
\begin{enumerate}
	\item Allocate {\tt varinfo\_t} structure for each variable. {\tt varinfo\_t} includes
		metadata and a solution set $\Sol(x)$.
	\item Find constraints in form of {\tt p = \&q} (direct constraints), and
		use them to initialize the solution sets.
	\item Find constraints in form of {\tt p = q} (copy constraints), and use
		them to build a constraint graph on variables. For example for {\tt p =
		q} constraint an edge {\tt q $\to$ p} is inserted to the graph.
	\item Find other constraints in form of {\tt *p = q} or {\tt p = *q} or
		containing field offsets (complex constraints) attach them to their
		corresponding vertices in the constraint graph.
	\item Find and contract strongly connected components in the graph.
	\item Put all graph vertices into a worklist.
	\item Take a vertex from the worklist. Process all complex constraints
		(possibly adding more copy edges to the graph) and propagate the set
		along the copy edges. Put all vertices modified by this operation into the
		worklist.
	\label{gcc-aa-propstep}
	\item Repeat step \ref{gcc-aa-propstep}. while there are elements in the worklist.
\end{enumerate}
\end{tcolorbox}
\caption{GCC implementation of Andersen's algorithm}
\label{figure-gcc-aliasalg}
\end{figure}

The implementation has two modes. One for intraprocedural points-to analysis
(PTA) and second for interprocedural points-to analysis (IPA PTA). In our case
this code reuse complicates the development. We want to keep the
intraprocedural analysis as it actually performs well, and modify the
interprodecural version which has performance issues as discusses in earlier
chapters.

\subsection{Improving the implementation}

In this work, we have temporarily duplicated the code into {\tt
ik-structlias.c}, which was then modified to implement only the interprocedural
case. This is just a temporary solution which enables us to run the original
and modified IPA PTA algorithm in a single execution and directly compare the
results. Furthermore, while benchmarking only the PTA code changes, the rest of
the compiler is identical.  The most important reason is to avoid case
separation in each function. The actual algorithm needs adjustments: we not
only need to pass different data types, but some operations are no longer
supported, and some operations should be used with greater care than they are
now. After inspecting the code, it became clear that the two algorithms need to
be separated.

To split the code, a few modifications has been done. Common functions were
marked static and renamed to avoid confusion. New query functions were added to
{\tt tree-ssa-alias.c}, which ask both the original and the new IPA PTA oracle
if the data is available. A new pass has been created, called {\tt kpta}, which
is controlled by new command line options:

\begin{itemize}
	\item {\tt -fipa-kpta} is an analog to {\tt -fipa-pta} and instructs the compiler to run the new IPA PTA algorithm during LTO phase, just after the original IPA PTA pass (if enabled).
	\item {\tt --param kpta-bloomap-size=n} instructs the compiler to use a bloomap of specific size.
	\item {\tt --param kpta-bloomap-precision=p} instructs the compiler to use a bloomap of specific precision. The value passed is inverted precision in percent, so a value of $100$ will result in a precision of $1\%$.
\end{itemize}


\subsection{Integrating Bloomaps}

Integrating bloomaps was relatively straightforward. The following steps were necessary, as some operations do not map well to Bloomap operations.

\begin{itemize}
	\item The main loop in {\tt solve\_graph()} keeps two solution sets: a
		current one and one from previous iteration. When new elements are to
		be propagated (via complex constraints), only the difference is
		examined to make changes. This is a nice optimization for classical
		bitmaps, Bloomap has no easy method to list difference and would have
		to be enumerated. This is unavoidable, but we do not store two bloomaps
		just for this optimization.
	\item Due to historical reasons, two identifiers were used in the
		algorithm. This is no longer necessary and one of them was removed.
	\item Finished solutions were deduplicated, merging same sets into one. This
		results in a less memory use, but is not worth the effort
		for bloomaps, as they are already very space efficient.
	\item Unnecessary bitmap enumerations were removed and the remaining ones
		optimized to reduce the number of passes.
\end{itemize}

\section{Performance evaluation}

By using Bloomaps instead of classical bitmaps, we have improved significantly
both the compile time and memory usage. See Figure
\ref{figure-new-old-comparison} for comparison. We measured compile time in
hours for the old IPA PTA algorithm, and we could only utilize 2 cores due to
memory requirements. The improved PTA algorithm finishes in just 16 minutes,
utilizing approximately the same memory, but working in 8 threads instead of 2.

\begin{figure}[h!]
\begin{subfigure}[b]{\textwidth}
	\centering
	\includegraphics{./graphs/firefox-ipa-pta-lto2/firefox-ipa-pta.pdf}
	\caption{{\tt libxul.so} with {\tt -fipa-pta -flto=2}}
	\label{figure-firefox-ipa-pta-lto2-2}
\end{subfigure}
\begin{subfigure}[b]{\textwidth}
	\centering
	\includegraphics{./graphs/firefox-ipa-kpta/firefox-ipa-kpta.pdf}
	\caption{Building libxul.so with {\tt -fipa-kpta -flto=8}}
	\label{figure-firefox-ipa-kpta}
\end{subfigure}
\caption{Comparison of build time with old and improved algorithm}
	\label{figure-new-old-comparison}
\end{figure}




\section{Future work}
