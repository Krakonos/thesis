%\end{document}
\newcommand{\definice}{\paragraph{Definice.}}

\chapter{Link-time optimizations}

In the beginning of this chapter, we will look into the composition of modern
programs, their codebase size and organization. We will continue with an
overview of compiler's workflow and introduce current LTO framework.


\section{Code organization and codebase size}

Let us star by examining some of the code bases for programs we use every day.
A lot of developers run Linux, Firefox (or other browser) and GCC every day, but
unless we're developing one of them, we don't really have an idea of how large
they are. They are enormous, containing millions of lines of code and growing. 
The chart in Figure \ref{figure-loc} show historical development over the past 10
years.

\begin{figure}[h!]
\label{figure-loc}
\centering
\includegraphics{graphs/loc/loc.pdf}
\caption{Codebase size of Firefox, Chrome and GCC over time. [Data provided by
	openhub.net]}
\end{figure}

As if it weren't enough, almost all of the code gets compiled info a single
binary, as seen in Figure \ref{figure-firefox-objsize}

\begin{figure}[h!]
\label{figure-firefox-objsize}
\centering
\includegraphics[angle=-90]{graphs/firefox-objsize/objsize.pdf}
\caption{Firefox 50.0.2 object sizes by binary}
\end{figure}



\section{The process of compilation and optimization}


\section{When to optimize?}

Now that we have a good intuition on what the compiler has to do, it's time to
think about when should the optimization happen.





\subsubsection{GCC}




\section{Compilation phases}

\TODO{je zapotřebí toto zmiňovat? možná raději napsat, jak funguje LTO}

Během překladu dochází k postupným změnám v reprezentaci dat, jak se program
transformuje z jazyka frontendu do stále jednodušších jazyků, dokud nevznikne
požadovaný spustitelný kód. Celkem dojde k několika fázím:

\begin{enumerate}
	\item Front End: Syntaktický analýza jazyka.
	\item Middle End: Vysokoúrovňové transformace a optimalizace.
	\item Back End: Nízkoúrovňové transformace a optimalizace.
\end{enumerate}

Během tohoto procesu je použito několik mezijazyků, které se dokonce mohou někdy
míchat (to je běžné, pokud se právě převádí z vyššího jazyka na nižší). Zde je
základní přehled, některé budou podrobněji rozepsány dále. Všechny používané
jazyky jsou úzce svázány s objekterý, pomocí kterých jsou reprezentovány.

\begin{description}
	\item[GENERIC] Nejvyšší mezijazyk, dovoluje vyjádřit funkci jako strom, a
		může obsahovat prakticky libovolná rozšíření specifická pro jazyk
		front-endu.
	\item[GIMPLE] Striktní verze jazyka GENERIC, speciálně každý výraz již smí
		obsahovat nanejvýš 3 operandy.
	\item[RTL] Nízkoúrovňový jazyk, podobající se spíše strojovým instrukcím
		cílové architektury. Obsahuje mimojiné jména registrů a práci se
		zásobníkem.
\end{description}

\subsection{Front End}

Front-end je v optimálním případě jediná část překladače, která zná informace o
jazyce, jeho syntaxi, a omezeních. Může svoji funkci provádět různě, a taktéž se
tak děje; nezávisle na tom však musí vydat reprezentaci, která je čitelná pro
další fáze překladu. Tou může být přímo GIMPLE, nebo GENERIC, který se na GIMPLE
převede.

\subsection{Middle End: Vysokoúrovňové transformace a optimalizace}

Jakmile je získán od frontendu kód v GIMPLu, provádí se většina optimalizací.
Dojde k rozdělení kódu na bloky a vybudování CFG (Control Flow Graph) mezi nimi,
čištění kódu, propagace konstant a výrazů, zpracování dat z profilování,
