%\end{document}
\newcommand{\definice}{\paragraph{Definice.}}

\chapter{Compilation and optimization}

In the beginning of this chapter, we will look into the composition of modern
programs, their codebase size and organization. We will continue with an
overview of compiler's workflow, introduce optimization passses and link-time
optimization framework.

\section{Code organization and codebase size}

Let us star by examining some of the code bases for programs we use every day.
A lot of developers run Linux, Firefox (or other browser) and GCC every day, but
unless we're developing one of them, we don't really have an idea of how large
they are. They are enormous, containing millions of lines of code and growing. 
The chart in Figure \ref{figure-loc} show historical development over the past 10
years.

\begin{figure}[h!]
\label{figure-loc}
\centering
\includegraphics{graphs/loc/loc.pdf}
\caption{Codebase size of Firefox, Chrome and GCC over time. [Data provided by
	openhub.net]}
\end{figure}

As if it weren't enough, almost all of the code gets compiled info a single
binary, as seen in Figure \ref{figure-firefox-objsize}

\begin{figure}[h!]
\label{figure-firefox-objsize}
\centering
\includegraphics[angle=-90]{graphs/firefox-objsize/objsize.pdf}
\caption{Firefox 50.0.2 object sizes by binary}
\end{figure}


\section{Compilation phases}

The ultimate goal of a compiler is to transform program written in a high-level
programming language into a binary representation that the processor
understands. The compiler usually has the following three components.

\paragraph{Front End} understands the input language, builts abstract syntax
tree and converts in into a common intermedialy language (IL) to all front ends
and the middle end.

\paragraph{Middle End} analyses the IL code and does most highlevel
optimizations. This includes splitting the code into basic blocks, building a
Control Flow Graph (CFG), dead code elimination, constant propagation, profile
driven transformations and many others \TODO{Ref forward.}

\paragraph{Back End} converts IL code into machine code, optimizing on the
lowest level, being able to schedule individual instructions and registers.

During this process multiple intermediary languages are used, sometimes more at
the same time (usually during transition to the lower-level language).

\begin{description}
	\item[GENERIC] is the highest-level IL used by the Front End, able to
		represent syntax trees and language-specific features.
	\item[GIMPLE] is tuple-based IL language, able to represent only simple
		expressions common to all languages. It is unable to represent many
		high-level constructs as for example loops.
	\item[RTL] (Register Transfer Language) is a low level language similar to
		machine code, containing algebraicly described instructions, as should
		be generated.
\end{description}
